# Detailed Notes: Isolation Levels in Databases

## **Introduction to Isolation Levels**

**Core Concept:** Relational databases provide **ACID guarantees**, and the **"I" in ACID is Isolation**. Isolation levels help us **tune** how transactions interact with each other.

### **What Isolation Levels Control**

```mermaid
graph TB
    subgraph Question["The Fundamental Question"]
        Q["How much does one transaction<br/>know about another transaction?"]
    end
    
    subgraph Parallel["Parallel Execution"]
        T1["Transaction 1<br/>on CPU1"]
        T2["Transaction 2<br/>on CPU2"]
    end
    
    IL[Isolation Levels<br/>â”â”â”â”â”â”<br/>Control visibility of<br/>uncommitted/committed changes]
    
    Q --> IL
    IL --> T1
    IL --> T2
    
    style Question fill:#1a1a1a,stroke:#888,stroke-width:3px
    style Parallel fill:#2d2d2d,stroke:#888,stroke-width:2px
    style IL fill:#3d2d1c,stroke:#7c5d4a,stroke-width:3px
    style T1 fill:#2d4a3c,stroke:#4a7c5c
    style T2 fill:#4a2d3c,stroke:#7c4a5c
```

**Definition:** Isolation levels **dictate how much one transaction knows about the other** when multiple transactions are executing parallelly.

---

## **The Four Standard Isolation Levels**

From **least isolated** to **most isolated**:

1. **Read Uncommitted** (Dirty Reads) - Least isolation
2. **Read Committed** (Default in most DBs) - Moderate isolation
3. **Repeatable Read** (MySQL default) - Strong isolation
4. **Serializable** - Maximum isolation

```mermaid
graph LR
    RU[Read Uncommitted<br/>â”â”â”â”â”â”<br/>Lowest Isolation<br/>Dirty Reads Allowed<br/>Best Performance]
    
    RC[Read Committed<br/>â”â”â”â”â”â”<br/>Moderate Isolation<br/>No Dirty Reads<br/>Good Performance]
    
    RR[Repeatable Read<br/>â”â”â”â”â”â”<br/>Strong Isolation<br/>Consistent Reads<br/>Moderate Performance]
    
    S[Serializable<br/>â”â”â”â”â”â”<br/>Complete Isolation<br/>Locking Reads<br/>Lower Performance]
    
    RU -->|Increasing Isolation| RC
    RC -->|Increasing Isolation| RR
    RR -->|Increasing Isolation| S
    
    style RU fill:#4a2d2d,stroke:#7c4a4a
    style RC fill:#3d3d2d,stroke:#6d6d4a
    style RR fill:#2d3d3d,stroke:#4a6d6d
    style S fill:#2d2d4a,stroke:#4a4a7c
```

---

## **1. Repeatable Read** (MySQL Default)

### **Definition**
**Consistent reads within the same transaction** - even if another transaction commits changes, you won't see them if you've already read that value.

### **Behavior**
- Once you read a value in a transaction, subsequent reads return the **same value**
- Changes made by other transactions are **NOT visible** even after they commit
- **Snapshot isolation** - transaction sees a consistent snapshot of the database

### **Practical Example**

```mermaid
sequenceDiagram
    participant T1 as Transaction 1<br/>(Terminal 1)
    participant DB as Database
    participant T2 as Transaction 2<br/>(Terminal 2)
    
    Note over T1,T2: Initial value: name = 'a'
    
    T1->>DB: START TRANSACTION
    T2->>DB: START TRANSACTION
    
    T1->>DB: SELECT * WHERE id=1
    DB-->>T1: Returns: name = 'a'
    
    T2->>DB: SELECT * WHERE id=1
    DB-->>T2: Returns: name = 'a'
    
    Note over T1: Updates name to 'a_t1'
    T1->>DB: UPDATE name = 'a_t1'
    T1->>DB: COMMIT âœ“
    
    Note over T2: Reads again AFTER T1 commits
    T2->>DB: SELECT * WHERE id=1
    DB-->>T2: Still returns: name = 'a'
    
    Note over T2: REPEATABLE READ:<br/>Sees same value as before<br/>even though T1 committed!
    
    T2->>DB: SELECT * WHERE id=1
    DB-->>T2: Still returns: name = 'a'
```

### **MySQL Demo**

**Check Isolation Level:**
```sql
mysql> SELECT @@transaction_ISOLATION;
+-------------------------+
| @@transaction_ISOLATION |
+-------------------------+
| REPEATABLE-READ         |
+-------------------------+
```

**Scenario:**

**Terminal 1 (T1):**
```sql
SET autocommit=0;
START TRANSACTION;
SELECT * FROM users WHERE id = 1;
-- Returns: id=1, name='a'

-- Update the name
UPDATE users SET name='a_t1' WHERE id=1;
COMMIT;
```

**Terminal 2 (T2):**
```sql
SET autocommit=0;
START TRANSACTION;
SELECT * FROM users WHERE id = 1;
-- Returns: id=1, name='a'

-- Wait for T1 to commit...

-- Read again AFTER T1 commits
SELECT * FROM users WHERE id = 1;
-- STILL returns: id=1, name='a'
-- NOT 'a_t1' because we already read this row!
```

### **Pros & Cons**

**âœ… Pros:**
- **Consistent reads** within a transaction
- Prevents non-repeatable reads
- Good for reporting and analytics

**âŒ Cons:**
- Can lead to **phantom reads** in some cases
- Transaction sees stale data if other transactions commit changes

---

## **2. Read Committed** (Most Common Default)

### **Definition**
Reads within the same transaction **always read fresh/committed values** from other transactions.

### **Behavior**
- Only sees **committed** data (no dirty reads)
- Each read gets the **latest committed value**
- Different reads within the same transaction can return different values

### **Practical Example**

```mermaid
sequenceDiagram
    participant T1 as Transaction 1
    participant DB as Database
    participant T2 as Transaction 2
    
    Note over T1,T2: Initial value: balance = 1000
    
    T1->>DB: START TRANSACTION
    T2->>DB: START TRANSACTION
    
    T1->>DB: SELECT balance
    DB-->>T1: Returns: 1000
    
    T2->>DB: UPDATE balance = 1500
    T2->>DB: COMMIT âœ“
    
    Note over T1: Reads again AFTER T2 commits
    T1->>DB: SELECT balance
    DB-->>T1: Returns: 1500 (NEW VALUE!)
    
    Note over T1: READ COMMITTED:<br/>Sees fresh committed value
    
    T1->>DB: SELECT balance
    DB-->>T1: Returns: 1500
```

### **Pros & Cons**

**âœ… Pros:**
- Always reads **fresh, committed data**
- Better for real-time systems
- Less blocking than higher isolation levels

**âŒ Cons:**
- **Multiple reads within same transaction are inconsistent**
- Can lead to non-repeatable reads
- Not suitable for operations requiring consistent snapshots

### **Use Case Example**

**Problem Scenario:**
```sql
START TRANSACTION;

-- Read 1: Get account balance
SELECT balance FROM accounts WHERE id = 123;  -- Returns: 1000

-- Another transaction updates and commits here...

-- Read 2: Calculate interest based on balance
SELECT balance FROM accounts WHERE id = 123;  -- Returns: 1500

-- Inconsistency! Same transaction, different values!
```

---

## **3. Read Uncommitted** (Dirty Reads)

### **Definition**
Reads **even uncommitted values** from other transactions. This is known as a **"dirty read"**.

### **Behavior**
- Can see changes from transactions that **haven't committed yet**
- If the other transaction rolls back, you saw data that never existed
- **Lowest isolation level** - highest performance

### **Practical Example**

```mermaid
sequenceDiagram
    participant T1 as Transaction 1
    participant DB as Database
    participant T2 as Transaction 2
    
    Note over T1,T2: Initial value: price = 100
    
    T1->>DB: START TRANSACTION
    T2->>DB: START TRANSACTION
    
    T1->>DB: UPDATE price = 500
    Note over T1: NOT COMMITTED YET!
    
    T2->>DB: SELECT price
    DB-->>T2: Returns: 500 (DIRTY READ!)
    
    Note over T2: T2 sees uncommitted change
    
    T1->>DB: ROLLBACK âŒ
    Note over T1: Change reverted!
    
    Note over T2: T2 read data that<br/>never actually existed!
```

### **Dangers of Dirty Reads**

**Scenario:**
```sql
-- Transaction 1
START TRANSACTION;
UPDATE products SET price = 50 WHERE id = 1;  -- Originally 100
-- Not committed yet...

-- Transaction 2 (READ UNCOMMITTED)
START TRANSACTION;
SELECT price FROM products WHERE id = 1;  -- Reads: 50 (dirty!)
-- Makes business decision based on price = 50

-- Transaction 1
ROLLBACK;  -- Price goes back to 100!

-- Transaction 2 made decisions based on data that never existed!
```

### **Pros & Cons**

**âœ… Pros:**
- **Highest performance** (no locking for reads)
- Useful for non-critical, approximate data
- Good for dashboards showing rough estimates

**âŒ Cons:**
- **Dirty reads** - can see data that gets rolled back
- Data integrity risks
- Should **rarely be used** in production

### **When to Use**

- Analytics dashboards where exact accuracy isn't critical
- Approximate counts or statistics
- Read-only reporting on non-critical data

---

## **4. Serializable** (Maximum Isolation)

### **Definition**
Every read is a **locking read**, and while one transaction reads, **others will have to wait**.

### **Behavior**
- Transactions appear to execute **serially** (one after another)
- Reads acquire **locks** on data
- Other transactions must wait for locks to be released
- **Complete isolation** - no concurrency issues

### **Implementation Note**
âš ï¸ **Depends on storage engine** - Implementation can vary by database engine, so **read documentation before you alter** the isolation level.

### **Practical Example**

```mermaid
sequenceDiagram
    participant T1 as Transaction 1
    participant DB as Database<br/>(with Locks)
    participant T2 as Transaction 2
    
    T1->>DB: START TRANSACTION
    T2->>DB: START TRANSACTION
    
    T1->>DB: SELECT * (LOCKING READ)
    DB-->>T1: Returns data + LOCK acquired ğŸ”’
    
    T2->>DB: SELECT * (tries to read)
    Note over T2: BLOCKED â¸ï¸<br/>Waiting for T1's lock
    
    Note over T1: T1 processes data...
    
    T1->>DB: COMMIT
    DB->>DB: Release lock ğŸ”“
    
    DB-->>T2: Now proceeds with read
    T2->>DB: COMMIT
```

### **Locking Behavior**

**Transaction 1:**
```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- This acquires a lock
SELECT * FROM orders WHERE customer_id = 100;

-- Do some processing...

COMMIT;  -- Lock released
```

**Transaction 2:**
```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;

-- This will WAIT until T1 commits
SELECT * FROM orders WHERE customer_id = 100;
-- Blocked here... â¸ï¸

COMMIT;
```

### **Pros & Cons**

**âœ… Pros:**
- **Complete isolation** - no concurrency anomalies
- Guaranteed consistency
- Prevents all read phenomena (dirty, non-repeatable, phantom)

**âŒ Cons:**
- **Significant performance impact** due to locking
- **Reduced concurrency** - transactions wait for each other
- Can lead to **deadlocks**
- Should only be used when absolutely necessary

### **When to Use**

- Financial transactions requiring absolute accuracy
- Critical operations where consistency is paramount
- Situations where data integrity cannot be compromised

---

## **Comparison Table**

| Isolation Level | Dirty Reads | Non-Repeatable Reads | Phantom Reads | Locking | Performance |
|----------------|-------------|---------------------|---------------|---------|-------------|
| **Read Uncommitted** | âœ“ Possible | âœ“ Possible | âœ“ Possible | Minimal | âš¡ Highest |
| **Read Committed** | âŒ Prevented | âœ“ Possible | âœ“ Possible | Moderate | âš¡âš¡ High |
| **Repeatable Read** | âŒ Prevented | âŒ Prevented | âœ“ Possible | More | âš¡âš¡âš¡ Moderate |
| **Serializable** | âŒ Prevented | âŒ Prevented | âŒ Prevented | Maximum | âš¡âš¡âš¡âš¡ Lowest |

---

## **Complete Isolation Levels Diagram**

```mermaid
graph TB
    subgraph IsolationLevels["Isolation Levels Spectrum"]
        RU[Read Uncommitted<br/>â”â”â”â”â”â”â”â”â”â”<br/>ğŸ”“ No locks on reads<br/>âœ“ Dirty reads possible<br/>âœ“ Non-repeatable reads<br/>âœ“ Phantom reads<br/>âš¡ Best performance]
        
        RC[Read Committed<br/>â”â”â”â”â”â”â”â”â”â”<br/>ğŸ”’ Short locks<br/>âŒ No dirty reads<br/>âœ“ Non-repeatable reads<br/>âœ“ Phantom reads<br/>âš¡âš¡ Good performance]
        
        RR[Repeatable Read<br/>â”â”â”â”â”â”â”â”â”â”<br/>ğŸ”’ Snapshot isolation<br/>âŒ No dirty reads<br/>âŒ No non-repeatable reads<br/>âœ“ Phantom reads possible<br/>âš¡âš¡âš¡ Moderate performance]
        
        S[Serializable<br/>â”â”â”â”â”â”â”â”â”â”<br/>ğŸ”’ Full locking<br/>âŒ No dirty reads<br/>âŒ No non-repeatable reads<br/>âŒ No phantom reads<br/>âš¡âš¡âš¡âš¡ Lower performance]
    end
    
    RU -->|More Isolation| RC
    RC -->|More Isolation| RR
    RR -->|More Isolation| S
    
    style IsolationLevels fill:#1a1a1a,stroke:#888,stroke-width:3px
    style RU fill:#4a2d2d,stroke:#7c4a4a,stroke-width:2px
    style RC fill:#3d3d2d,stroke:#6d6d4a,stroke-width:2px
    style RR fill:#2d3d3d,stroke:#4a6d6d,stroke-width:2px
    style S fill:#2d2d4a,stroke:#4a4a7c,stroke-width:2px
```

---

## **Read Phenomena Explained**

### **1. Dirty Read**
Reading uncommitted data from another transaction that may get rolled back.

### **2. Non-Repeatable Read**
Reading the same row twice in a transaction returns different values because another transaction modified and committed it.

### **3. Phantom Read**
Re-running the same query returns a different set of rows because another transaction inserted or deleted rows.

---

## **Practical Guidelines**

### **Choosing the Right Isolation Level**

```mermaid
graph TD
    START{Choose Isolation Level}
    
    START --> Q1{Need absolute<br/>consistency?}
    Q1 -->|Yes| Q2{Can tolerate<br/>performance hit?}
    Q1 -->|No| Q3{Need to avoid<br/>dirty reads?}
    
    Q2 -->|Yes| SER[Use SERIALIZABLE]
    Q2 -->|No| RR1[Use REPEATABLE READ]
    
    Q3 -->|Yes| Q4{Need consistent<br/>snapshot?}
    Q3 -->|No| RU_USE[Consider READ UNCOMMITTED<br/>for non-critical reads]
    
    Q4 -->|Yes| RR2[Use REPEATABLE READ]
    Q4 -->|No| RC_USE[Use READ COMMITTED]
    
    style SER fill:#2d2d4a,stroke:#4a4a7c,stroke-width:3px
    style RR1 fill:#2d3d3d,stroke:#4a6d6d,stroke-width:2px
    style RR2 fill:#2d3d3d,stroke:#4a6d6d,stroke-width:2px
    style RC_USE fill:#3d3d2d,stroke:#6d6d4a,stroke-width:2px
    style RU_USE fill:#4a2d2d,stroke:#7c4a4a,stroke-width:2px
```

### **Default Isolation Levels**

- **MySQL/MariaDB**: REPEATABLE READ
- **PostgreSQL**: READ COMMITTED
- **SQL Server**: READ COMMITTED
- **Oracle**: READ COMMITTED

### **Setting Isolation Levels**

**Session Level:**
```sql
-- MySQL
SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;

-- PostgreSQL
SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

**Transaction Level:**
```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
START TRANSACTION;
-- Your queries here
COMMIT;
```

**Global Level (MySQL):**
```sql
SET GLOBAL TRANSACTION ISOLATION LEVEL READ COMMITTED;
```

---

## **Performance Impact**

```mermaid
graph LR
    subgraph Performance["Performance vs Consistency Trade-off"]
        P1[Read Uncommitted<br/>â”â”â”â”â”â”<br/>Highest Throughput<br/>Lowest Consistency]
        
        P2[Read Committed<br/>â”â”â”â”â”â”<br/>High Throughput<br/>Moderate Consistency]
        
        P3[Repeatable Read<br/>â”â”â”â”â”â”<br/>Moderate Throughput<br/>High Consistency]
        
        P4[Serializable<br/>â”â”â”â”â”â”<br/>Lowest Throughput<br/>Highest Consistency]
    end
    
    P1 -.->|Performance decreases| P2
    P2 -.->|Performance decreases| P3
    P3 -.->|Performance decreases| P4
    
    P4 -.->|Consistency increases| P3
    P3 -.->|Consistency increases| P2
    P2 -.->|Consistency increases| P1
    
    style Performance fill:#1a1a1a,stroke:#888,stroke-width:3px
    style P1 fill:#1c3d2d,stroke:#3c7c5c
    style P2 fill:#2d3d2d,stroke:#5d6d4d
    style P3 fill:#3d3d2d,stroke:#6d6d3d
    style P4 fill:#3d2d1c,stroke:#7c5d3c
```

---

## **Key Takeaways**

âœ… **Isolation levels control transaction visibility** - They determine what one transaction can see from another

âœ… **Trade-off between consistency and performance** - Higher isolation = more consistency but lower performance

âœ… **Engine-dependent implementation** - Always check your database's documentation for specific behavior

âœ… **Choose based on use case:**
- **Read Uncommitted**: Non-critical analytics, approximate data
- **Read Committed**: General-purpose applications (most common)
- **Repeatable Read**: Consistent snapshots, reporting
- **Serializable**: Critical financial transactions, absolute consistency required

âœ… **Default isn't always right** - Understand your application's needs and choose accordingly

âœ… **Test thoroughly** - Isolation level bugs are subtle and can lead to data inconsistencies

âš ï¸ **Warning**: Always read your database engine's documentation before altering isolation levels, as implementation details can vary significantly between different storage engines and databases.
